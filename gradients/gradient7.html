<!doctype html>
<html lang="uk">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>Blue Blob Gradient (fixed)</title>
    <style>
        html,body{height:100%;margin:0;background:#000;overflow:hidden}
        canvas{display:block;position:fixed;inset:0}
    </style>
</head>
<body>
<script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    let renderer, scene, camera, mesh, t0;

    init();
    animate();

    function init(){
        renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.setSize(innerWidth, innerHeight, false);
        renderer.setClearColor(0x000000, 0.0); // прозорий canvas
        document.body.appendChild(renderer.domElement);

        scene  = new THREE.Scene();
        camera = new THREE.OrthographicCamera(-1,1,1,-1,0,1);

        const geo = new THREE.PlaneGeometry(2,2);

        const mat = new THREE.ShaderMaterial({
            uniforms:{
                iResolution:{ value:new THREE.Vector3(innerWidth, innerHeight, 1) },
                iTime:{ value:0.0 },
                // палітра
                uBlueDeep:{ value:new THREE.Color('#0000de') },
                uBlueElec:{ value:new THREE.Color('#2a66ff') },
                uMagenta :{ value:new THREE.Color('#ff46d6') },
                uAlphaMax:{ value:0.95 }
            },
            vertexShader: /* glsl */`
      varying vec2 vUv;
      void main(){
        vUv = uv;
        gl_Position = vec4(position, 1.0);
      }
    `,
            fragmentShader: /* glsl */`
      precision highp float;

      uniform vec3  iResolution;
      uniform float iTime;
      uniform vec3  uBlueDeep, uBlueElec, uMagenta;
      uniform float uAlphaMax;
      varying vec2  vUv;

      // ---------- Simplex noise (2D) ----------
      vec3 mod289(vec3 x){ return x - floor(x*(1.0/289.0))*289.0; }
      vec2 mod289(vec2 x){ return x - floor(x*(1.0/289.0))*289.0; }
      vec3 permute(vec3 x){ return mod289(((x*34.0)+1.0)*x); }

      float snoise(vec2 v){
        const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                            0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                           -0.577350269189626,  // -1.0/sqrt(3.0)
                            0.024390243902439); // 1.0/41.0
        vec2 i = floor(v + dot(v, C.yy));
        vec2 x0 = v - i + dot(i, C.xx);
        vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
        vec4 x12 = x0.xyxy + C.xxzz;
        x12.xy -= i1;

        i = mod289(i);
        vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))
                       + i.x + vec3(0.0, i1.x, 1.0));

        vec3 m = max(0.5 - vec3(dot(x0,x0),
                                 dot(x12.xy,x12.xy),
                                 dot(x12.zw,x12.zw)), 0.0);
        m = m*m;
        m = m*m;

        vec3 x = 2.0*fract(p*C.www) - 1.0;
        vec3 h = abs(x) - 0.5;
        vec3 ox = floor(x + 0.5);
        vec3 a0 = x - ox;

        m *= 1.79284291400159 - 0.85373472095314*(a0*a0 + h*h);

        vec3 g;
        g.x = a0.x * x0.x + h.x * x0.y;
        g.y = a0.y * x12.x + h.y * x12.y;
        g.z = a0.z * x12.z + h.z * x12.w;

        return 130.0 * dot(m, g);
      }

      float fbm(vec2 p){
        float f = 0.0;
        float a = 0.5;
        mat2 r = mat2(0.8, -0.6, 0.6, 0.8);
        for(int i=0;i<5;i++){
          f += a * snoise(p);
          p = r*p*2.0 + 10.0;
          a *= 0.5;
        }
        return f;
      }

      // м'який еліптичний профіль (гладкі краї)
      float softMask(vec2 p, vec2 radii, float feather){
        vec2 q = p / radii;
        float r2 = dot(q,q);
        float g  = exp(-r2*1.8);
        return pow(g, feather);
      }

      void main(){
        float asp = iResolution.x / iResolution.y;

        // стабільні нормалізовані координати (не залежать від DPR)
        vec2 uv = vUv * 2.0 - 1.0;
        uv.x *= asp;

        // центр плями трохи зміщуємо вліво/вгору, щоб займала ~пів екрана
        vec2 center = vec2(-0.15*asp, 0.05);
        vec2 p = uv - center;

        // еліптична «основа» блоба
        vec2 radii = vec2(0.8*asp, 0.55);
        // «дихання»: легка зміна масштабу в часі
        radii *= 1.0 + 0.06*sin(iTime*0.8);

        // домен-ворпінг: робимо контур живішим
        vec2 warp = vec2(fbm(p*1.2 + iTime*0.25),
                         fbm(p*1.8 - iTime*0.21));
        p += (warp - 0.5) * 0.25;

        // м'яка маска фігури
        float mask = softMask(p, radii, 1.25);

        // додаткове «бахромлення» краю шумом
        float edgeN = fbm(p*2.2 + 7.0 - iTime*0.2);
        mask *= smoothstep(0.15, 1.0, edgeN + 0.4);

        if(mask < 0.005) discard;

        // колірні переливи: deep blue → electric blue → магента
        float n1 = fbm(p*1.6 + iTime*0.15);
        float n2 = fbm(p*3.0 - iTime*0.10 + 11.0);
        float mixBE = clamp(0.5 + 0.5*(0.7*n1 + 0.3*sin(iTime*0.6)), 0.0, 1.0);
        vec3 col = mix(uBlueDeep, uBlueElec, pow(mixBE, 0.9));
        col = mix(col, uMagenta, 0.20 + 0.25*n2);

        // легкий «глянець» у напрямку умовного світла
        vec2 L = normalize(vec2(0.6, 0.8));
        float ndotl = clamp(dot(normalize(p + 1e-5), L), 0.0, 1.0);
        col += vec3(0.12, 0.13, 0.20) * pow(ndotl, 8.0);

        gl_FragColor = vec4(col, mask * uAlphaMax);
      }
    `,
            transparent:true
        });

        mesh = new THREE.Mesh(geo, mat);
        scene.add(mesh);

        t0 = performance.now();
        addEventListener('resize', onResize, {passive:true});
    }

    function onResize(){
        renderer.setSize(innerWidth, innerHeight, false);
        mesh.material.uniforms.iResolution.value.set(innerWidth, innerHeight, 1);
    }

    function animate(){
        const t = (performance.now() - t0) * 0.001;
        mesh.material.uniforms.iTime.value = t;
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
    }
</script>
</body>
</html>
