<!doctype html>
<html lang="uk">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>Abstract Blue Gradient — water ripples</title>
    <style>
        html,body{height:100%;margin:0;background:#000;overflow:hidden}
        canvas{display:block;position:fixed;inset:0}
    </style>
</head>
<body>
<script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    let renderer, scene, camera, mesh, t0;
    let aspect = innerWidth/innerHeight;

    // курсор у координатах шейдера (-1..1 з урахуванням аспекту)
    const mouse   = new THREE.Vector2(0,0);
    const mouseSm = new THREE.Vector2(0,0);

    // буфер „сплесків” для хвиль (коло на 8 записів)
    const RIPPLE_COUNT = 8;
    const ripplePos = Array.from({length:RIPPLE_COUNT}, ()=>new THREE.Vector2(9999,9999)); // поза екраном = „неактивно”
    const rippleTime = new Float32Array(RIPPLE_COUNT).fill(-1);
    let rippleIndex = 0;

    init();
    animate();

    function init(){
        renderer = new THREE.WebGLRenderer({
            antialias:true, alpha:true, premultipliedAlpha:true, powerPreference:'high-performance'
        });
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.setSize(innerWidth, innerHeight, false);
        renderer.setClearColor(0x000000, 0.0);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);

        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera(-1,1,1,-1,0,1);

        const geo = new THREE.PlaneGeometry(2,2);

        const mat = new THREE.ShaderMaterial({
            uniforms:{
                iResolution : { value:new THREE.Vector3(innerWidth, innerHeight, 1) },
                iTime       : { value:0.0 },

                // курсор (для дуже легкого впливу центру)
                uMouse      : { value:new THREE.Vector2(0,0) },

                // палітра під референс
                uBlueDeep   : { value:new THREE.Color('#0000de') },
                uBlueElec   : { value:new THREE.Color('#2a66ff') },
                uTeal       : { value:new THREE.Color('#54ffe7') },
                uMagenta    : { value:new THREE.Color('#ff46d6') },

                // м’якість/прозорість
                uFeather    : { value:1.45 },
                uAlphaMax   : { value:0.95 },

                // дуже слабкий фолоу, щоб майже не зрушувати шари
                uFollowMain : { value:0.02 },
                uFollowTeal : { value:0.03 },
                uFollowMag  : { value:0.02 },

                // ---- параметри хвиль ----
                uNow        : { value:0.0 },
                uRipplePos  : { value: ripplePos },
                uRippleT    : { value: rippleTime },
                uRippleAmp  : { value: 0.02 }, // було 0.08 → зробили вдвічі менше
                uRippleFreq : { value: 20.0 }, // можна залишити, частота норм
                uRippleSpeed: { value: 2.8 },  // можна трохи зменшити швидкість
                uDecaySpace : { value: 2.8 },  // було 2.2 → сильніше згасає з відстанню
                uDecayTime  : { value: 1.2 }   // було 1.6 → швидше затухає по часу
            },
            vertexShader: /* glsl */`
      varying vec2 vUv;
      void main(){ vUv = uv; gl_Position = vec4(position,1.0); }
    `,
            fragmentShader: /* glsl */`
      precision highp float;

      uniform vec3  iResolution;
      uniform float iTime;

      uniform vec2  uMouse;

      uniform vec3  uBlueDeep, uBlueElec, uTeal, uMagenta;
      uniform float uFeather, uAlphaMax;
      uniform float uFollowMain, uFollowTeal, uFollowMag;

      // ripples
      const int RIPPLE_COUNT = 8;
      uniform float uNow;
      uniform vec2  uRipplePos[RIPPLE_COUNT];
      uniform float uRippleT[RIPPLE_COUNT];
      uniform float uRippleAmp, uRippleFreq, uRippleSpeed, uDecaySpace, uDecayTime;

      varying vec2 vUv;

      // --- noise ---
      vec3 mod289(vec3 x){return x - floor(x*(1.0/289.0))*289.0;}
      vec2 mod289(vec2 x){return x - floor(x*(1.0/289.0))*289.0;}
      vec3 permute(vec3 x){return mod289(((x*34.0)+1.0)*x);}
      float snoise(vec2 v){
        const vec4 C=vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);
        vec2 i=floor(v+dot(v,C.yy));
        vec2 x0=v-i+dot(i,C.xx);
        vec2 i1=(x0.x>x0.y)?vec2(1.0,0.0):vec2(0.0,1.0);
        vec4 x12=x0.xyxy+C.xxzz; x12.xy-=i1;
        i=mod289(i);
        vec3 p=permute(permute(i.y+vec3(0.0,i1.y,1.0))+i.x+vec3(0.0,i1.x,1.0));
        vec3 m=max(0.5-vec3(dot(x0,x0),dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)),0.0);
        m=m*m; m=m*m;
        vec3 x=2.0*fract(p*C.www)-1.0;
        vec3 h=abs(x)-0.5;
        vec3 ox=floor(x+0.5);
        vec3 a0=x-ox;
        m*=1.79284291400159-0.85373472095314*(a0*a0+h*h);
        vec3 g;
        g.x=a0.x*x0.x+h.x*x0.y;
        g.yz=a0.yz*x12.xz+h.yz*x12.yw;
        return 130.0*dot(m,g);
      }
      float fbm(vec2 p){
        float f=0.0, a=0.5;
        mat2 r=mat2(0.8,-0.6,0.6,0.8);
        for(int i=0;i<5;i++){ f+=a*snoise(p); p=r*p*2.0+11.0; a*=0.5; }
        return f;
      }
      mat2 rot(float a){ float s=sin(a), c=cos(a); return mat2(c,-s,s,c); }

      float softEllipse(vec2 p, vec2 radii, float feather){
        vec2 q = p / radii;
        float r2 = dot(q,q);
        float g = exp(-r2*1.6);
        return pow(g, 1.0/feather);
      }

      float smokeStruct(vec2 p, vec2 dir){
        dir = normalize(dir + 1e-6);
        vec2 n = vec2(-dir.y, dir.x);
        vec2 uv = vec2(dot(p, dir)*3.1, dot(p, n)*0.9);
        float n1 = fbm(uv*1.2 + vec2(0.0, iTime*0.25));
        float n2 = fbm(uv*2.0 + vec2(7.0, -iTime*0.18));
        return clamp(0.5 + 0.5*(n1*0.6 + n2*0.4), 0.0, 1.0);
      }

      // displacement від „водяних” кругових хвиль
      vec2 rippleDisp(vec2 uv){
        vec2 disp = vec2(0.0);
        for(int i=0;i<RIPPLE_COUNT;i++){
          float t0 = uRippleT[i];
          if(t0 < 0.0) continue; // неактивно

          vec2  c   = uRipplePos[i];
          float dt  = uNow - t0;
          float r   = length(uv - c);

          // хвиля: sin(kr - w t) * затухання по часу та відстані
          float wave = sin(uRippleFreq*r - uRippleSpeed*dt);
          float env  = exp(-uDecaySpace*r) * exp(-dt/uDecayTime);

          // напрям від центру
          vec2 dir = normalize(uv - c + 1e-6);
          disp += dir * (uRippleAmp * wave * env);
        }
        return disp;
      }

      void main(){
    float asp = iResolution.x / iResolution.y;
vec2 uv = vUv * 2.0 - 1.0;  // стабільний 0..1, не залежить від DPR
uv.x *= asp;

        // легкий дрейф сцени
vec2 sceneDrift = vec2(0.02*asp*sin(iTime*0.25), 0.015*cos(iTime*0.2));
uv -= sceneDrift;

// рахувати хвилю в до-дрейфовому просторі:
vec2 disp = rippleDisp(uv + sceneDrift);
vec2 uvd  = uv + disp;

        // курсор (для дуже слабкого фолоу центрів)
        vec2 uvMouse = uMouse;

        // --- Блоб 1 (синій) ---
        vec2 C1 = vec2(-0.40*asp, -0.12) + uvMouse * uFollowMain;
        float angle1 = 0.15*sin(iTime*0.4);
        vec2  R1 = vec2(1.35*asp, 0.95) * (1.0 + 0.06*sin(iTime*0.9));
        vec2  p1 = rot(angle1) * (uvd - C1);
        p1 += (vec2(fbm(p1*1.1 + iTime*0.20), fbm(p1*1.7 - iTime*0.17)) - 0.5) * 0.35;
        float m1 = softEllipse(p1, R1, uFeather);
        vec3  c1 = mix(uBlueDeep, uBlueElec, pow(smokeStruct(p1, vec2(1.0,0.0)), 0.8));

        // --- Блоб 2 (бірюзовий блік) ---
        vec2 C2 = vec2( 0.18*asp, -0.02) + uvMouse * uFollowTeal;
        float angle2 = -0.12 + 0.12*cos(iTime*0.5);
        vec2  R2 = vec2(0.95*asp, 0.75) * (1.0 + 0.07*cos(iTime*0.8+1.1));
        vec2  p2 = rot(angle2) * (uvd - C2);
        p2 += (vec2(fbm(p2*1.6 + 7.0 + iTime*0.22), fbm(p2*2.0 + 3.1 - iTime*0.21)) - 0.5) * 0.28;
        float m2 = softEllipse(p2, R2, uFeather*1.05);
        vec3  c2 = mix(uBlueElec, uTeal, pow(smokeStruct(p2, vec2(0.9,0.2)), 0.85));

        // --- Блоб 3 (фіолетова смуга) ---
        vec2 C3 = vec2(-0.02*asp, 0.08) + uvMouse * uFollowMag;
        float angle3 = 0.9 + 0.15*sin(iTime*0.6);
        vec2  R3 = vec2(0.55*asp, 0.18) * (1.0 + 0.05*sin(iTime*1.1));
        vec2  p3 = rot(angle3) * (uvd - C3);
        p3 += (vec2(fbm(p3*2.3 - 5.0 + iTime*0.25), fbm(p3*1.9 + 2.0 - iTime*0.3)) - 0.5) * 0.18;
        float m3 = softEllipse(p3, R3, uFeather*0.9) * smoothstep(-0.15, 0.35, p3.x);
        vec3  c3 = mix(uBlueElec, uMagenta, 0.70);

        // --- Комбінування шарів ---
        float a1 = m1 * 0.95;
        float a2 = m2 * 0.95;
        float a3 = m3 * 0.85;

        float A = a1;
        vec3  C = c1;
        C = (C*A + c3*a3*(1.0-A)) / max(A + a3*(1.0-A), 1e-4);
        A = 1.0 - (1.0-A)*(1.0-a3);
        C = (C*A + c2*a2*(1.0-A)) / max(A + a2*(1.0-A), 1e-4);
        A = 1.0 - (1.0-A)*(1.0-a2);

        // легкий глянець
        float shine = pow(smoothstep(0.65,1.0,max(m1,max(m2,m3))), 2.0);
        C += vec3(0.10,0.13,0.20) * shine;

        float outA = clamp(A, 0.0, uAlphaMax);
        if(outA < 0.002) discard;
        gl_FragColor = vec4(C, outA);
      }
    `,
            transparent:true,
            depthTest:false,
            depthWrite:false,
            blending:THREE.NormalBlending
        });

        mesh = new THREE.Mesh(geo, mat);
        scene.add(mesh);

        // дуже плавне відстеження курсора
        addEventListener('pointermove', (e)=>{
            const x = (e.clientX / innerWidth) * 2 - 1;
            const y = (e.clientY / innerHeight) * -2 + 1;
            mouse.set(x * aspect, y);          // ← важливо: множимо X на aspect
            pushRipple(mouse.x, mouse.y);       // пушимо ті ж координати, що й у шейдер
        }, {passive:true});

        addEventListener('resize', onResize, {passive:true});
        t0 = performance.now();
    }

    function pushRipple(x, y){
        ripplePos[rippleIndex].set(x, y);
        rippleTime[rippleIndex] = (performance.now()-t0)*0.001; // секунди
        rippleIndex = (rippleIndex + 1) % RIPPLE_COUNT;
    }

    function onResize(){
        aspect = innerWidth/innerHeight;
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.setSize(innerWidth, innerHeight, false);
        mesh.material.uniforms.iResolution.value.set(innerWidth, innerHeight, 1);
    }

    function animate(){
        const t = (performance.now()-t0)*0.001;
        const u = mesh.material.uniforms;

        // плавність реакції на курсор
        mouseSm.lerp(mouse, 0.04); // ще повільніше/плавніше
        u.uMouse.value.copy(mouseSm);

        // оновлюємо час для хвиль і передаємо буфери
        u.uNow.value = t;
        // (передані масиви ripplePos/rippleTime вже привʼязані як references у uniforms)

        u.iTime.value = t;
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
    }
</script>
</body>
</html>
