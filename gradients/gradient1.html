<!doctype html>
<html lang="uk">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>3D Fog Gradient (WebGL)</title>
    <style>
        html,body{height:100%;margin:0;background:#000;overflow:hidden}
        #fog-canvas{position:fixed;inset:0;width:100%;height:100%;display:block;pointer-events:none;z-index:0}
        .content{position:relative;z-index:1;color:#fff;padding:6vmin 8vmin;font:600 4vw/1.1 system-ui,-apple-system,Segoe UI,Inter,Roboto,sans-serif;text-shadow:0 2px 16px rgba(0,0,0,.55)}
        .content p{max-width:60ch;opacity:.85;font-weight:400;font-size:clamp(14px,1.4vw,18px)}
    </style>
</head>
<body>
<canvas id="fog-canvas"></canvas>
<div class="content">
    <h1>Lorem ipsum dolor sit amet.</h1>
    <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Minima molestias necessitatibus quae recusandae similique unde.</p>
</div>
<div class="ht"></div>

<!-- non-module для Webflow/звичайних сторінок -->
<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<script>
    (function () {
        const CONFIG = {
            color1: 0x2040ff,  // синій
            color2: 0x6b00ff,  // фіолет
            intensity: 0.9,
            flowSpeed: 0.085,
            bandCurve: 0.95,
            noiseScale: 1.35,
            grain: 0.025,
            alpha: 0.92,
            dprMax: 1.75
        };

        const canvas = document.getElementById('fog-canvas');
        const renderer = new THREE.WebGLRenderer({
            canvas, antialias:false, alpha:true, powerPreference:'high-performance', premultipliedAlpha:true
        });
        renderer.setClearColor(0x000000, 0);
        if (renderer.outputColorSpace) renderer.outputColorSpace = THREE.SRGBColorSpace;

        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
        const geometry = new THREE.PlaneGeometry(2,2);

        const vert = `
      precision highp float;
      void main(){ gl_Position = vec4(position,1.0); }
    `;

        const frag = `
      precision highp float;
      uniform vec2  uRes;
      uniform float uTime;
      uniform vec3  uColor1; uniform vec3 uColor2;
      uniform float uIntensity,uFlow,uBandCurve,uNoiseScale,uGrain,uAlpha;

      vec3 mod289(vec3 x){return x - floor(x*(1.0/289.0))*289.0;}
      vec4 mod289(vec4 x){return x - floor(x*(1.0/289.0))*289.0;}
      vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}
      vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314*r;}

      float snoise(vec3 v){
        const vec2 C=vec2(1.0/6.0,1.0/3.0); const vec4 D=vec4(0.0,0.5,1.0,2.0);
        vec3 i=floor(v+dot(v,C.yyy)); vec3 x0=v-i+dot(i,C.xxx);
        vec3 g=step(x0.yzx,x0.xyz); vec3 l=1.0-g;
        vec3 i1=min(g.xyz,l.zxy); vec3 i2=max(g.xyz,l.zxy);
        vec3 x1=x0-i1+C.xxx; vec3 x2=x0-i2+C.yyy; vec3 x3=x0-D.yyy;
        i=mod289(i);
        vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));
        vec4 j=p-49.0*floor(p*(1.0/49.0));
        vec4 x_=floor(j*(1.0/7.0)); vec4 y_=floor(j-7.0*x_);
        vec4 x=(x_*2.0+0.5)/7.0-1.0; vec4 y=(y_*2.0+0.5)/7.0-1.0; vec4 h=1.0-abs(x)-abs(y);
        vec4 b0=vec4(x.xy,y.xy), b1=vec4(x.zw,y.zw);
        vec4 s0=floor(b0)*2.0+1.0, s1=floor(b1)*2.0+1.0; vec4 sh=-step(h,vec4(0.0));
        vec4 a0=b0.xzyw + s0.xzyw*sh.xxyy; vec4 a1=b1.xzyw + s1.xzyw*sh.zzww;
        vec3 g0=vec3(a0.xy,h.x), g1=vec3(a0.zw,h.y), g2=vec3(a1.xy,h.z), g3=vec3(a1.zw,h.w);
        vec4 norm=taylorInvSqrt(vec4(dot(g0,g0),dot(g1,g1),dot(g2,g2),dot(g3,g3)));
        g0*=norm.x; g1*=norm.y; g2*=norm.z; g3*=norm.w;
        vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0); m*=m;
        return 42.0*dot(m*m, vec4(dot(g0,x0),dot(g1,x1),dot(g2,x2),dot(g3,x3)));
      }

      float fbm(vec3 p){ float a=.5,f=0.; for(int i=0;i<5;i++){ f+=a*snoise(p); p=p*2.1+0.15; a*=.5; } return f; }

      void main(){
        vec2 uv=gl_FragCoord.xy/uRes; vec2 p=uv-.5; p.x*=uRes.x/uRes.y;
        float band = p.y + .15*sin(p.x*1.3) - .20*cos(p.x*.6+1.2);
        band*=uBandCurve;

        float t=uTime*uFlow;
        vec3 q=vec3(p*uNoiseScale, t);
        vec3 r=vec3(fbm(q+vec3(0.0)), fbm(q+vec3(5.2,1.3,0.0)), fbm(q+vec3(1.7,9.2,0.0)));
        vec3 warped=q + .5*r;
        float n=fbm(warped);

        float ribbon=smoothstep(.25, -.35, band + n*.55);
        float fog=smoothstep(.15, .95, n);
        float density=clamp(ribbon*1.2 + fog*.65, 0., 1.); density=pow(density,1.1)*uIntensity;

        vec3 col=mix(uColor1,uColor2, clamp(.35+.65*n,0.,1.));
        float vign=smoothstep(1.2, .25, length(p)*1.1); density*=vign;

        float grain=(fract(sin(dot(gl_FragCoord.xy, vec2(12.9898,78.233)))*43758.5453 + t*37.0)-.5)*uGrain;
        density=clamp(density+grain,0.,1.);

        vec4 outc=vec4(col, density*uAlpha);
        outc.rgb*=outc.a; // премультиплікована альфа
        gl_FragColor=outc;
      }`;

        const material = new THREE.ShaderMaterial({
            vertexShader: vert, fragmentShader: frag, transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
            uniforms:{
                uRes:{value:new THREE.Vector2(1,1)},
                uTime:{value:0},
                uColor1:{value:new THREE.Color(CONFIG.color1)},
                uColor2:{value:new THREE.Color(CONFIG.color2)},
                uIntensity:{value:CONFIG.intensity},
                uFlow:{value:CONFIG.flowSpeed},
                uBandCurve:{value:CONFIG.bandCurve},
                uNoiseScale:{value:CONFIG.noiseScale},
                uGrain:{value:CONFIG.grain},
                uAlpha:{value:CONFIG.alpha}
            }
        });

        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        function resize(){
            const dpr = Math.min(window.devicePixelRatio||1, CONFIG.dprMax);
            renderer.setPixelRatio(dpr);
            renderer.setSize(window.innerWidth, window.innerHeight, false);
            material.uniforms.uRes.value.set(renderer.domElement.width, renderer.domElement.height);
        }
        window.addEventListener('resize', resize, {passive:true});
        resize();

        let last = performance.now();
        function raf(now){
            material.uniforms.uTime.value += (now-last)/1000; last=now;
            renderer.render(scene,camera);
            requestAnimationFrame(raf);
        }
        requestAnimationFrame(raf);

        if (!renderer.capabilities.isWebGL2 && !renderer.capabilities.isWebGL){
            canvas.style.display='none';
            document.body.style.background=
                'radial-gradient(120vw 60vh at 20% 70%, rgba(32,64,255,.35), transparent 60%),'+
                'radial-gradient(90vw 45vh at 70% 30%, rgba(107,0,255,.45), transparent 60%), #000';
        }
    })();
</script>
</body>
</html>
